	sentence	context	pred_type	params	values
0	If you want to have thousands instead, you should consider using connection pooling software to reduce the connection overhead	This is very important to some of the below parameters (particularly work_mem) because there are some memory resources that are or can be allocated on a per-client basis, so the maximum number of clients suggests the maximum possible memory use	4	{'work_mem'}	[]
1	If you have a system with 1GB or more of RAM, a reasonable starting value for shared_buffers is 1/4 of the memory in your system	If you have a system with 1GB or more of RAM, a reasonable starting value for shared_buffers is 1/4 of the memory in your system	4	{'shared_buffers'}	['1GB', '1/4']
2	If you have less RAM you'll have to account more carefully for how much RAM the OS is taking up; closer to 15% is more typical there	If you have a system with 1GB or more of RAM, a reasonable starting value for shared_buffers is 1/4 of the memory in your system	4	{'shared_buffers'}	['15%']
3	Be aware that if your system or Postgre SQL build is 32-bit, it might not be practical to set shared_buffers above 2 ~ 2.5GB	Be aware that if your system or Postgre SQL build is 32-bit, it might not be practical to set shared_buffers above 2 ~ 2.5GB	4	{'shared_buffers'}	['32-bit', '2', '2.5GB']
4	Setting effective_cache_size to 1/2 of total memory would be a normal conservative setting, and 3/4 of memory is a more aggressive but still reasonable amount	Setting effective_cache_size to 1/2 of total memory would be a normal conservative setting, and 3/4 of memory is a more aggressive but still reasonable amount	0	{'effective_cache_size'}	['1/2', '3/4']
5	Unless you're running on a very small configuration, you'll almost certainly be better setting this to at least 10, which also allows usefully increasing the completion target	Setting checkpoint_segments to a much larger value improves that	4	{'checkpoint_segments'}	['on', '10']
6	Normally the large settings (>64/1GB) are only used for bulk loading	Setting checkpoint_segments to a much larger value improves that	4	{'checkpoint_segments'}	[]
7	You can spread those writes out further, lowering the average write overhead, by increasing the checkpoint_completion_target parameter to its useful maximum of 0.9 (aim to finish by the time 90% of the next checkpoint is here) rather than the default of 0.5 (aim to finish when the next one is 50% done)	You can spread those writes out further, lowering the average write overhead, by increasing the checkpoint_completion_target parameter to its useful maximum of 0.9 (aim to finish by the time 90% of the next checkpoint is here) rather than the default of 0.5 (aim to finish when the next one is 50% done)	4	{'checkpoint_completion_target'}	['0.9', '90%', '0.5', '50%']
8	The maximum value for the parameter was also increased from 1000 to 10,000 in 8.4	The starting default_statistics_target value was raised from 10 to 100 in Postgre SQL 8.4	4	{'default_statistics_target'}	['1000', '10', '000', '8.4']
9	Benchmarking generally suggests that just increasing to 1MB is enough for some large systems, and given the amount of RAM in modern servers allocating a full WAL segment (16MB, the useful upper-limit here) is reasonable	On Postgre SQL 9.0 and earlier, increasing wal_buffers from its tiny default of a small number of kilobytes is helpful for write-heavy systems	4	{'wal_buffers'}	['1MB', '16MB']
10	If you do not use two phase commit (and if you don't know what it is, you don't use it), then you can set this value to 0	max_prepared_transactions	4	{'max_prepared_transactions'}	['0']
11	The value should be set to 15% to 25% of the machine’s total RAM	#shared_buffers = 128MB	0	{'#shared_buffers'}	['15%', '25%']
12	For example: if your machine’s RAM size is 32 GB, then the recommended value for shared_buffers is 8 GB	For example: if your machine’s RAM size is 32 GB, then the recommended value for shared_buffers is 8 GB	0	{'shared_buffers'}	['32', '8']
13	The recommended value is 25% of your total machine RAM	The default value of shared_buffer is set very low and you will not get much benefit from that	0	{'shared_buffer'}	['25%']
14	You should try some lower and higher values because in some cases we achieve good performance with a setting over 25%	The default value of shared_buffer is set very low and you will not get much benefit from that	4	{'shared_buffer'}	['25%']
15	For testing purposes, let’s increase this to 256MB and see if there is any impact on cost	For the above query, we have a work_mem of only 2MB	5	{'work_mem'}	['256MB', 'on']
16	If your application is designed such that performance is more important than the reliability, then turn off synchronous_commit	If your application is designed such that performance is more important than the reliability, then turn off synchronous_commit	4	{'synchronous_commit'}	['off']
17	I understad that most of this suggestions like using 25% of RAM for shared_buffer is for servers that are only running Postgre SQL and not for servers that also run a web server or other services	I understad that most of this suggestions like using 25% of RAM for shared_buffer is for servers that are only running Postgre SQL and not for servers that also run a web server or other services	4	{'shared_buffer'}	['25%']
18	If you have a dedicated database server with 1 GB or more of RAM, a reasonable initial value for shared_buffers is 25% of your system's memory	If you have a dedicated database server with 1 GB or more of RAM, a reasonable initial value for shared_buffers is 25% of your system's memory	4	{'shared_buffers'}	['1', '25%']
19	The default setting is about 3% of shared_buffers, not less than 64KB or more than the size of a WAL segment (usually 16MB)	The default setting is about 3% of shared_buffers, not less than 64KB or more than the size of a WAL segment (usually 16MB)	4	{'shared_buffers'}	['3%', '64KB', '16MB)']
20	Setting this value to at least a few MB can improve write performance on a server with many concurrent transactions	The default setting is about 3% of shared_buffers, not less than 64KB or more than the size of a WAL segment (usually 16MB)	4	{'shared_buffers'}	['on']
21	A reasonable value would be 50% of the RAM	effective_cache_size	4	{'effective_cache_size'}	['50%']
22	set to roughly 25% of available RAM on the system	shared_buffers = <num> — Editing this option is the simplest	0	{'shared_buffers'}	['25%', 'on']
23	a very good option for databases unless you have more than 6 disks in	(pg_xlog) on a separate disk ( or stripe ) all by itself	4	{'pg_xlog'}	['6']
